/// <reference types="@figma/plugin-typings" />
import type { INodeTreeNode } from './interfaces/INodeTree';

export * from './interfaces';

/**
 * An Object with string or symbol keys and unknown values
 */
export interface SomeObject extends Record<string | symbol, unknown> {}

export type Cloneable =
  | null
  | undefined
  | number
  | string
  | boolean
  | Array<Cloneable>
  | Uint8Array
  | { [key: string | number | symbol]: Cloneable }
  | Record<any, any>;

/**
 * This function ONLY returns false for `undefined` and `null`,
 * other values such as `false`, `0`, `''`, etc are considered to exist.
 *
 * It is also a nice syntax sugar for filtering :) ()`.filter(Exists)`).
 *
 * @param obj The object to check for existence
 */
export function Exists<T>(obj?: T | null): obj is T {
  return obj !== undefined && obj !== null;
}

/**
 * This function returns `false` for ANY falsy value,
 * i.e. `undefined`, `null`, `false`, `0`, `BigInt(0)`, `''`, and `NaN`.
 *
 * @param obj The object to check for emptiness
 */
export function NotEmpty<T>(obj?: T): obj is T {
  return Boolean(obj);
}

/**
 * A union type of all possible values of type T
 */
export type SomeValueOf<T> = T[keyof T];

export type ValueForKey<T, K> = K extends keyof T ? T[K] : never;

export interface ILayerRef {
  id: string;
  name: string;
}

export enum MutationKind {
  Property = 'property',
  Effect = 'effect',
}

export enum Direction {
  H = 'horizontal',
  V = 'vertical',
}

export type ComponentPropertyValue = string | boolean;

export type DefaultValueTypeFor<T extends ComponentPropertyType> =
  T extends 'BOOLEAN'
    ? boolean
    : T extends 'TEXT'
    ? string
    : T extends 'VARIANT'
    ? string
    : T extends 'INSTANCE_SWAP'
    ? string
    : never;

export type GenericPropertyDefinition = {
  type: ComponentPropertyType;
  defaultValue: string | boolean;
  preferredValues?: InstanceSwapPreferredValue[];
  variantOptions?: string[];
};

/**
 * IPropertyDefinition replaces the ComponentPropertyDefinitions from the Figma API
 * with a more precise and type-safe specification of the many property definitions.
 */
export type FigmaPropertyDefinition =
  | {
      // TODO: we need to check if the name property really exists in Figma types
      // name: string;
      variantOptions?: string[];
      preferredValues?: {
        type: 'COMPONENT' | 'COMPONENT_SET';
        key: string;
      }[];
    } & (
      | {
          type: 'BOOLEAN';
          defaultValue: boolean;
        }
      | {
          type: 'TEXT';
          defaultValue: string;
        }
      | {
          type: 'VARIANT';
          defaultValue: string;
          variantOptions: string[];
        }
      | {
          type: 'INSTANCE_SWAP';
          defaultValue: string;
          preferredValues: InstanceSwapPreferredValue[];
        }
    );

export type IPropertyDefinition = FigmaPropertyDefinition & {
  name: string;
  target: InstanceNode | ComponentNode | ComponentSetNode;
  linked?: IPropertyDefinitionLinked[];
};

export type IPropertyDefinitionLinked = FigmaPropertyDefinition & {
  name: string;
  target: InstanceNode | ComponentNode | ComponentSetNode;
};

export type IPropertyDefinitionFor<T extends ComponentPropertyType> = {
  name: string;
  type: T;
  defaultValue: DefaultValueTypeFor<T>;
} & IPropertyDefinition;

export type BlueprintNode = ComponentNode | ComponentSetNode;

/**
 * Same as ComponentNode, but with a more semantic name meaning
 * that this component node is a variant generated by us.
 *
 * TODO: Settle on creating instances or cloning components and remove the unnecessary type
 */
export type Variant = ComponentNode | InstanceNode;
export type MutableNode = InstanceNode | ComponentNode | ComponentSetNode;

// TODO: check if this can be replaced with `SceneNode`
export type FigmaNode = SceneNode & BaseNode & ChildrenMixin;
export type FigmaNodeId = string;

export enum HeaderPlacement {
  Top = 'top',
  Bottom = 'bottom',
  Left = 'left',
  Right = 'right',
}

export interface AppComponentProps {
  tree: {
    root: INodeTreeNode<BlueprintNode>;
  };
  frames: ILayerRef[];

  screen: 'generate' | 'empty-selection' | 'loading';
}

/**
 * DataSource Types
 */

export type VariableCriteria = {
  namePattern?: RegExp;
  collectionId: string;
};
