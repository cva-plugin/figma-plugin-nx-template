import { GenerationRule, PropertyRule } from '@code/generation/rules';
import { type IRulesTreeNode, type IRulesTree } from '@cva/shared';
import type {
  IPropertyDefinition,
  FigmaNode,
  BlueprintNode,
  INodeTreeNode,
  LinkedPropertyFilterConfig,
  FilterConfig,
  DisableVarianceFilterConfig,
} from '@shared/types';
import type { INodeTree } from '@shared/interfaces/INodeTree';
import logger from '@shared/logger';
import { findCompProperties } from './findCompProperties';
import { buildVarianceTree } from './buildVarianceTree';
import { deepClone } from '@shared/utils';
import { figmaNodePath } from '@code/utils';
import { findDescendantNodeById } from './node-utils';

/**
 * @internal
 *
 * TODO: Review documentation
 *
 * A tree with all the information needed to generate variants.
 * Variants are generated by traversing the tree and varying the
 * properties' values of Figma `SceneNode`s in the tree.
 *
 * @remarks
 * The variation occur due to component properties, special effects applied to
 * SceneNodes, and possibly other rules not yet implement at the time of writing
 * this doc. See { @tutorial VarianceRules } for more information.
 *
 * How the variance tree works:
 *
 * The constructor takes a a Figma {@link ComponentNode} or {@link ComponentSet} that will become root of the tree
 * in the `master` param and builds itself by analyzing its descendants.
 *
 * The work of building the tree was divided in 3 steps:
 *   1. {@link VarianceTree.buildVarianceTree} - This method traverses the descendants of the `master` and creates a tree of
 *      {@link FigmaNode}s. The tree is built by calling {@link buildVarianceTree} recursively.
 *
 *   2. After the tree is ready, {@link bubbleUpProperties} is called create a single {@link IPropertyDefinition} object containing
 *      all the properties that can be varied in the tree.
 *
 * Before generating the variants, {@link countVariants} is called to calculate the number of variants that will be created
 * and prevent us from generating an insane amount of variants.
 *
 * @see {@link VariantFactory} To lean about how the variants are generated.
 */
export class VarianceTree implements INodeTree {
  public root!: INodeTreeNode<ComponentNode>;
  public properties!: Record<string, IPropertyDefinition>;
  /**
   * create a tree at `comp` is the component selected  and
   * `context` is the base tree if don't have yet, put null for create a one.
   */
  constructor(blueprint: BlueprintNode, filters?: FilterConfig[]) {
    if (blueprint.type !== 'COMPONENT') {
      throw new Error('We only support Component nodes for now.');
    }
    // logger.tree("paint styles", figma.getSelectionColors())
    this.buildVarianceTree(blueprint).bubbleUpProperties().addPath();
    if (filters) {
      this.applyFilter(filters);
    }

    logger.tree('tree', this);
  }

  /**
   * Traverses a VarianceTree calling `fn` for each node.
   */
  public traverse(
    fn: (node: INodeTreeNode) => void,
    startingNode: INodeTreeNode = this.root
  ) {
    startingNode.children.map((childNode) => this.traverse(fn, childNode));
    fn(startingNode);
  }

  /**
   * Traverse and Map nodes to a new value by applying `fn`.
   *
   * Traverses a VarianceTree mapping each node to a new value by applying `fn`.
   */
  public traverseMap<TNewNode extends { children: TNewNode[] }>(
    fn: (node: INodeTreeNode) => TNewNode,
    startingNode: INodeTreeNode = this.root
  ): TNewNode {
    const newParent = fn(startingNode);
    newParent.children = startingNode.children.map((child) =>
      this.traverseMap(fn, child)
    );

    return newParent;
  }
  /**
   * Performs a bottom-up traversal of the variance tree and applies a specified function to each node.
   *
   * @param fn A function that takes two parameters: `bubble` and `treeRoot`. The `bubble` parameter is an array of results from the children nodes, and `treeRoot` is the current node being processed. The function should return a result of type `TResult`.
   * @param root The root node of the subtree to traverse. If not specified, the method starts the traversal from the root of the entire variance tree.
   * @returns TResult The type of the result returned by the function.
   */
  public bubbleUp<TResult>(
    fn: (bubble: TResult[], treeRoot: INodeTreeNode) => TResult,
    root: INodeTreeNode = this.root
  ): TResult {
    return fn(
      root.children.map((childNode) => this.bubbleUp(fn, childNode)),
      root
    );
  }

  /**
   * @see {@link buildVarianceTree}
   */
  private buildVarianceTree(blueprint: ComponentNode): this {
    this.root = buildVarianceTree(blueprint);

    return this;
  }
  /**
   * Sends the filters to the correct methods in which they will be applied in the tree.
   */
  private applyFilter(filters: FilterConfig[]) {
    filters.map((filter) => {
      if (filter.type === 'LinkedPropertiesFilter') this.linkProps(filter);
      if (filter.type === 'DisableVarianceFilter')
        this.disableNodeVariance(filter);
    });
  }
  public getGenerationRules(): GenerationRule[] {
    const rules: GenerationRule[] = [];

    Object.values(this.root.properties).forEach((prop) => {
      if (prop.target.type == 'INSTANCE') {
        const path = figmaNodePath(prop.target, this.root.node);
        rules.push(new PropertyRule(this.root.node, path, prop));
      }
    });

    return rules;
  }
  /**
   * Disables variation on the node in question if it is an existing node in the tree
   */
  disableNodeVariance(filter: DisableVarianceFilterConfig) {
    const treeNode = findDescendantNodeById(filter.nodeId, this.root);
    if (treeNode) {
      treeNode.varianceDisabled = true;
    }
    this.bubbleUpProperties();
  }
  /**
   * Take the user defined properties of the component and all of it's descendants
   */
  findAllProps(comp: FigmaNode): Record<string, IPropertyDefinition> {
    return findCompProperties(comp);
  }

  /**
   * Combine all the properties of the tree into a single Map of properties
   */
  private bubbleUpProperties(): this {
    const props: Record<string, IPropertyDefinition> = {};
    this.traverse((n: INodeTreeNode) => {
      if (n.varianceDisabled == false) {
        Object.entries(n.properties).map(
          ([k, v]) => (props[`${v.target.id}/${k}`] = v)
        );
      }
    });

    this.properties = props;

    return this;
  }
  /**
   *
   * Add path from current node to root node.
   * Which makes it easy to map the tree to the Figma component
   */
  private addPath(): this {
    this.traverse((tree: INodeTreeNode) => {
      if (tree.node.id != this.root.id) {
        const path = figmaNodePath(tree.node, this.root.node);
        if (this.getNodeAtPath(path) != undefined) {
          tree.path = path;
        }
      }
    });
    return this;
  }
  // public treePath(currentNode: SceneNode): string[] {}
  /**
   * Links properties between nodes in the variance tree based on the provided filter configuration.
   *
   * @param filter - An array of `LinkedPropertyFilterConfig` objects specifying the linking configuration.
   */
  public linkProps(filter: LinkedPropertyFilterConfig): void {
    const sourceNode = findDescendantNodeById(filter.sourceNodeId, this.root);
    const targetNode = findDescendantNodeById(filter.targetNodeId, this.root);
    if (sourceNode != undefined && targetNode != undefined) {
      if (
        sourceNode.properties[filter.sourceProperty] &&
        targetNode.properties[filter.sourceProperty]
      ) {
        sourceNode.properties[filter.sourceProperty].linked?.push(
          targetNode.properties[filter.sourceProperty]
        );
        delete targetNode.properties[filter.sourceProperty];
      } else {
        throw Error(`
        the component: ${targetNode.name} has already been linked.`);
      }
    }
    this.bubbleUpProperties();
  }

  /**
   * Count the total number of variants that will be generated
   *
   * @todo: This is a naive implementation that only takes into account variation through properties
   * @param props A map of the combined properties of all the nodes in the variance tree
   * @see bubbleUpProperties
   */
  public countVariants() {
    return Object.values(this.properties).reduce<number>((total, prop) => {
      switch (prop.type) {
        case 'VARIANT':
          return total * (prop.variantOptions.length || 1);

        // case 'BOOLEAN':
        //   return total * 2;

        // case 'INSTANCE_SWAP':
        //   return total * (prop.preferredValues.length || 1);
      }

      return total;
    }, 1);
  }

  /**
   * Looks for a node at `path` using `context` as the
   * root and considering path[0] to be it's first child.
   *
   * @param path The path of the node starting from context
   * @param context [Optional] When not set, context will be the tree root
   */
  public getNodeAtPath(
    path: string | string[],
    context?: INodeTreeNode
  ): INodeTreeNode | undefined {
    if (!Array.isArray(path)) {
      path = path.split('.');
    }

    context = context ?? this.root;

    if (
      path.length >= 1 &&
      this.getChildByName(path[0], context) == undefined
    ) {
      path.shift();
      this.getNodeAtPath(path, context);
    }
    const next = this.getChildByName(path[0], context);

    if (next === undefined) {
      return undefined;
    }

    if (path.length === 1) {
      return next;
    }

    return this.getNodeAtPath(path.slice(1), next);
  }

  public getChildByName(
    name: string,
    parent: INodeTreeNode = this.root
  ): INodeTreeNode | undefined {
    return parent.children.find((child) => child.name === name);
  }

  asRulesTree(): IRulesTree {
    const root = this.traverseMap<IRulesTreeNode>(
      (node: INodeTreeNode): IRulesTreeNode => {
        const props = deepClone(node.properties);

        const mutationRule: IRulesTreeNode = {
          id: node.id,
          name: node.name,
          type: node.node.type,
          children: [],
          path: node.path,
          filters: [],
          properties: props,
          varianceDisabled: node.varianceDisabled,
        };

        logger.tree('Mapping node', node, 'to rule', mutationRule);

        return mutationRule;
      }
    );

    return { root };
  }
}
